{"ast":null,"code":"import { DataSource } from '@angular/cdk/collections';\nimport { map } from 'rxjs/operators';\nimport { of as observableOf, merge } from 'rxjs'; // TODO: replace this with real data from your application\n\nconst EXAMPLE_DATA = [{\n  SrNo: 1,\n  products: 'Hydrogen',\n  productType: 'variant',\n  category: 'soap',\n  action: ''\n}];\n/**\n * Data source for the ProductTable view. This class should\n * encapsulate all logic for fetching and manipulating the displayed data\n * (including sorting, pagination, and filtering).\n */\n\nexport class ProductTableDataSource extends DataSource {\n  constructor() {\n    super();\n    this.data = EXAMPLE_DATA;\n  }\n  /**\n   * Connect this data source to the table. The table will only update when\n   * the returned stream emits new items.\n   * @returns A stream of the items to be rendered.\n   */\n\n\n  connect() {\n    if (this.paginator && this.sort) {\n      // Combine everything that affects the rendered data into one update\n      // stream for the data-table to consume.\n      return merge(observableOf(this.data), this.paginator.page, this.sort.sortChange).pipe(map(() => {\n        return this.getPagedData(this.getSortedData([...this.data]));\n      }));\n    } else {\n      throw Error('Please set the paginator and sort on the data source before connecting.');\n    }\n  }\n  /**\n   *  Called when the table is being destroyed. Use this function, to clean up\n   * any open connections or free any held resources that were set up during connect.\n   */\n\n\n  disconnect() {}\n  /**\n   * Paginate the data (client-side). If you're using server-side pagination,\n   * this would be replaced by requesting the appropriate data from the server.\n   */\n\n\n  getPagedData(data) {\n    if (this.paginator) {\n      const startIndex = this.paginator.pageIndex * this.paginator.pageSize;\n      return data.splice(startIndex, this.paginator.pageSize);\n    } else {\n      return data;\n    }\n  }\n  /**\n   * Sort the data (client-side). If you're using server-side sorting,\n   * this would be replaced by requesting the appropriate data from the server.\n   */\n\n\n  getSortedData(data) {\n    if (!this.sort || !this.sort.active || this.sort.direction === '') {\n      return data;\n    }\n\n    return data.sort((a, b) => {\n      var _a, _b;\n\n      const isAsc = ((_a = this.sort) === null || _a === void 0 ? void 0 : _a.direction) === 'asc';\n\n      switch ((_b = this.sort) === null || _b === void 0 ? void 0 : _b.active) {\n        // SrNo: number;\n        // products: string;\n        // productType: string;\n        // category: string;\n        // action: string;\n        case 'SrNo':\n          return compare(a.SrNo, b.SrNo, isAsc);\n\n        case 'products':\n          return compare(+a.products, +b.products, isAsc);\n\n        case 'productType':\n          return compare(+a.productType, +b.productType, isAsc);\n\n        case 'category':\n          return compare(+a.category, +b.category, isAsc);\n\n        case 'action':\n          return compare(+a.action, +b.action, isAsc);\n\n        default:\n          return 0;\n      }\n    });\n  }\n\n}\n/** Simple sort comparator for example ID/Name columns (for client-side sorting). */\n\nfunction compare(a, b, isAsc) {\n  return (a < b ? -1 : 1) * (isAsc ? 1 : -1);\n}","map":null,"metadata":{},"sourceType":"module"}